<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>js高程--22.14-函数绑定--bind()</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
            font-size: 14px;
            list-style: none;
        }

        input[type=button] {
            padding: 1em 5em;
            border: 0;
            margin-top: 20px;
            border-radius: 4px;
        }

        #run {
            background: lightskyblue;
        }

        #stop {
            background: lightcoral;
            margin-left: 20px;
        }
    </style>
</head>
<body>
<!-- 此效果的完整示例在 《js--B方法--插件》 -- <17-8-23-requestAnimationFrame> 下 -->
<div class="contain" style="width:80%; margin:20px auto; height:10em; background:#f0f0f0;">
    <div id="test" style="width:1px;height:17px;background:lightseagreen;">0%</div>
    <input type="button" value="RUN" id="run"/>
    <input type="button" value="STOP" id="stop"/>
</div>

<script type="text/javascript">
    var ele = document.getElementById("test"),
        run = document.getElementById("run"),
        stop = document.getElementById("stop");

    var handler = {
        message: "Event Handled",
        handleClick: function () {
            alert(this.message);
        }
    };

    /**
     * 运行下面这段代码我们想弹出的是 Event Handled，然而是 undefined, 这个问题在于没有保存handler.handleClick() 的环境，
     * 所以 this 对象最后指向了 DOM 按钮而非 handler(在 IE8中 this 指向 window )。
     * 而且我们知道调用函数不加 () 只是调用函数的指针。调用函数的指针，函数不会立即执行，只有条件触发才执行。
     */
    // 1. 第一次我们会这样写，但是输入结果却是错的
    // run.addEventListener("click",handler.handleClick, false);


    /**
     * 解决方案在 onclick 事件处理程序内使用了一个闭包直接调用 handler.handleClick()。 当然这是特定于这段代码的解决方案。
     * 创建多个闭包可能会令代码变得难于理解和调试，因此许多js库实现了一个可以将函数绑定到制定环境的函数。 这个函数一般都叫bind。
     * */

    var handler2 = {
        message: "Event Handled",
        handleClick: function (event) {
            alert(this.message + ":" + event.type);
        }
    };

    // 2. 第二次改良后的代码
    // 这里的 event 为 click 点击事件传入的。 (原因: 在触发 DOM 上的某个事件时，会产生一个事件对象 event ，
    // 这个对象中包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。)
    // run.addEventListener("click", function (event) {
    //     handler2.handleClick(event);
    // }, false);    // Event Handled


    /**
     * 这个函数似乎简单，但其功能是非常强大的。在 bind() 中创建一个闭包，闭包使用 apply() 调用传入的参数，并给 apply() 传递
     * context 对象和参数。 注意这里使用的 arguments 对象是内部函数的，而非 bind() 的。 它会在给定环境中执行被传入的函数并
     * 给出所有参数。      context(上下文)
     * */
    /*function bind (fn, context) {
        return function () {
            return fn.apply(context, arguments);
        }
    }*/

    // 3. 改良2 : (这里有一点不理解的是为什么通过bind()这种方式，handler2.handleClick(event)中也照样可以取到event.)
    // run.addEventListener("click", bind(handler2.handleClick, handler), false);


    /**
     * ES5 为所有函数定义了一个原生的 bind() 方法，进一步简单了操作。 换句话说我们不用自己定义 bind() 函数了，直接使用。示例见下:
     * */
    run.addEventListener("click", handler.handleClick.bind(handler), false);


    /** 20180502 - add: 这个示例讲解在 《js设计模式与编程实践》 中有更好的写法
     *  ------
     * github-clone\ECMAScript6-Study\Javascript设计模式与编程实践\第一部分--基础知识\第2章\P32-Function.prototype.bind实现.js
     */


</script>
</body>
</html>
