# 深入理解 JS 系列（14）：作用域链 (Scope Chain)

## 目录 (Catalog)


## 生词 (New Words)


## 内容 (Content)

- ```js
    let x = 10;
    function foo() {
        let y = 20;
        console.log(x + y);
    }
    foo(); // 30
  ```

### [[Scope]]
- 函数 “foo” 如何访问到变量 “x” ？ --> 理论上函数应该能访问一个更高一层上下文的变量对象。
  实际上它正是这样，这种机制是通过函数内部的 [[scope]] （(我们不能使用，供 js 引擎使用)）
  属性来实现的。
- **[[scope]] 是所有父变量对象的层级链，处于当前函数上下文之上**，在函数创建时存于其中。
- 注意这重要的一点 -- [[scope]] 在函数创建时被存储--静态（不变的），永远永远，
  直至函数销毁。即：函数可以永不调用，但 [[scope]] 属性已经写入，并存储在函数对象中。
- 另外一个需要考虑的是--与作用域链对比，[[scope]] 是函数的一个属性而不是上下文.

- 函数 foo 的 [[Scope]] 如下：（伪代码）
  ```base
    foo.[[Scope]] = {
        globalContext.VO;   // === global
    }
  ```

 ### 闭包
- 在 ECMAScript 中，闭包与函数的 [[scope]] 直接相关，正如我们提到的那样，[[scope]]
  属性在函数创建时被存储，与函数共存亡。实际上，闭包是函数代码和其 [[scope]] 的结合。
  因此，作为其对象之一，[[Scope]] 包括在函数内创建的词法作用域（父变量对象）。当函数进一
  步激活时，在变量对象的这个词法链（静态的存储于创建时）中，来自较高作用域的变量将被搜寻。



