# 第 8 章 -- 发布-订阅模式

## 本章目录 (Catalog)
- 8.1 现实中的 发布-订阅模式
- 8.2 发布-订阅模式的作用
- 8.3 DOM 事件
- 8.4 自定义事件
- 8.5 发布-订阅模式的通用实现
- 8.6 取消订阅的事件
- 8.7 真实的例子 - 网站登录
- 8.8 全局的发布-订阅对象
- 8.9 模块间通信
- 8.10 必须先订阅再发布吗
- 8.11 全局事件的命名冲突
- 8.12 JavaScript 实现发布-订阅模式的便利性
- 8.13 小结


## 生词 (New Words)
- **dependence [dɪ'pɛndəns] --n.[对...的]依赖, 依存[on, upon]**




## Added 
- 发布订阅模式简单实现
  ```js
    // - Dependence 收集订阅者 和 通知发布
    class Dep{
        constructor() {
            // + subs 数组为一个缓存列表, 用来存放和回调函数
            this.subs = [];
        }
        // - addSub 方法负责收集订阅者, 收集的订阅者是 Watcher 构造函数的实例.
        addSub(watcher) {
            this.subs.push(watcher);
        }
        // - notify 就是通知发布, 那么怎么发布呢? A: forEach 循环 subs 数组
        //   收集到的 Watcher 构造函数的实例, 实例调用原型上的 update 方法.
        notify() {
             // + 数组的 slice() 方法, 创建当前数组的一个副本
            const subs = this.subs.slice();
            for (let i = 0, l = subs.length; i < l; i++) {
                subs[i].update();
            }
        }
        // - 移除一个订阅者 watcher
        removeSub(watcher) {
            remove(this.subs, watcher);
        }
    }

    // - Question: 下面 new Watcher(fn) 中添加的就是一个匿名函数, 那么这个 item
    //   是根据什么判断条件来执行移除的?
    function remove(arr, item) {
        if (arr.length) {
            const index = arr.indexOf(item);
            if (index > -1) {
                return arr.splice(index, 1);
            }
        }
    }

    // - 订阅者构造函数，我们默认规定每个构造函数的实例都有一个 update 方法,
    //   构造函数 Watcher 收到的 fn 为一个要添加的订阅者
    class Watcher{
        constructor(fn) {
            this.fn = fn;
        }
        // - update 方法的目的就是执行当前构造函数调用时传入的订阅者(fn)
        update() {
            this.fn();
        }
    }

    let watcher = new Watcher(function() {
        console.log('我是一个订阅者 fn');
    });

    let dep = new Dep();
    dep.addSub(watcher);
    dep.addSub(watcher);
    console.log(dep.subs);
    dep.notify();
  ```
- **Tip: 自己写代码时下面书本上给出的示例更完整且易懂.**


## 本章内容 (Contents)
- `发布-订阅模式` 又叫 `观察者模式`，它定义对象间的一种一对多的依赖关系，当一个对象的状态
  发生改变时，所有依赖于它的对象都将得到通知。在 js 开发中，我们一般用 `事件模型` 来替代
  传统的发布-订阅模式。
### 8.1 现实中的 发布-订阅模式
### 8.2 发布-订阅模式的作用
- **(1)发布—订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案.**  
  比如，我们可以订阅 ajax 请求的 error、 success 等事件。或者如果想在动画的每一帧
  完成之后做一些事情，那我们可以订阅一个事件，然后在动画的每一帧完成之后发布这个事件。
  在异步编程中使用发布—订阅模式，我们就无需过多关注对象在异步运行期间的内部状态，
  而只需要订阅感兴趣的事件发生点。
- **(2)发布—订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外**
  **一个对象的某个接口.**   
  发布—订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼此的细节，但这不影响
  它们之间相互通信。当有新的订阅者出现时，发布者的代码不需要任何修改；同样发布者
  需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以
  自由地改变它们。
### 8.3 DOM 事件
- 实际上，只要我们曾经在 DOM 节点上面绑定过事件函数，那我们就曾经使用过发布—订阅模式，
  来看看下面这两句简单的代码发生了什么事情：
  ```js
    document.body.addEventListener('click', function() {
        console.log(2);
    }, false)
  ```
- 在这里需要监控用户点击 document.body 的动作，但是我们没办法预知用户将在什么时候点击.
  所以我们订阅 document.body 上的 click 事件，当 body 节点被点击时， body 节点便会
  向订阅者发布这个消息。这很像购房的例子，购房者不知道房子什么时候开售，于是他在订阅消息
  后等待售楼处发布消息。
### 8.4 自定义事件
- 除了 DOM 事件，我们还会经常实现一些自定义的事件，这种依靠自定义事件完成的发布—订阅模式
  可以用于任何 JavaScript 代码中。
- 现在看看如何一步步实现发布—订阅模式。
    + 首先要指定好谁充当发布者[`Dependence`]（比如售楼处）；
    + 然后给发布者添加一个缓存列表[`this.subs = []`]，用于存放(`addSub() 内添加`)
      回调函数(`Watcher 实例`) 以便通知订阅者（售楼处的花名册）；
    + 最后发布(`update()`)消息的时候，发布者会遍历(`notify() 中`)这个缓存列表，依次
      触发里面存放的订阅者回调函数（遍历花名册，挨个发短信）。
### 8.5 发布-订阅模式的通用实现
### 8.6 取消订阅的事件
- 8.5-8.6 发布订阅模式的通用实现 + 取消订阅的事件 完整源码见同级目录:   
  **`8.5-6-发布订阅模式通用实现.html`**
### 8.7 真实的例子 - 网站登录
- 假如我们正在开发一个商城网站，网站里有 header 头部、nav 导航、消息列表、
  购物车等模块。这几个模块的渲染有一个共同的前提条件，就是必须先用 ajax 异步
  请求获取用户的登录信息。这是很正常的，比如用户的名字和头像要显示在 header
  模块里，而这两个字段都来自用户登录后返回的信息。
- 至于 ajax 请求什么时候能成功返回用户信息，这点我们没有办法确定。现在的情节
  看起来像极了售楼处的例子，小明不知道什么时候开发商的售楼手续能够成功办下来。
- 但现在还不足以说服我们在此使用发布—订阅模式，因为异步的问题通常也可以用
  回调函数来解决。更重要的一点是，我们不知道除了 header 头部、 nav 导航、
  消息列表、购物车之外，将来还有哪些模块需要使用这些用户信息。如果它们和
  用户信息模块产生了强耦合，比如下面这样的形式:
  ```js
    login.success(function(data) {
        header.setAvatar(data.avatar);  // - 设置 header 模块的头像
        nav.setAvatar(data.avatar);     // - 设置导航模块的头像
        message.refresh();              // - 刷新消息列表
        cart.refresh();                 // - 刷新购物车列表
    })
  ```
- 现在登录模块是我们负责编写的，但我们还必须了解 header 模块里设置头像的方法
  叫setAvatar、购物车模块里刷新的方法叫 refresh，这种耦合性会使程序变得僵硬,
  header 模块不能随意再改变 setAvatar 的方法名，它自身的名字也不能被改为
  header1、 header2。 这是针对具体实现编程的典型例子，针对具体实现编程
  是不被赞同的。
- 等到有一天，项目中又新增了一个收货地址管理的模块，这个模块本来是另一个同事
  所写的，而此时你正在马来西亚度假，但是他却不得不给你打电话：“Hi，登录之后
  麻烦刷新一下收货地址列表。”于是你又翻开你 3 个月前写的登录模块，在最后部分
  加上这行代码:
  ```js
    login.success(function(data) {
        header.setAvatar(data.avatar);  // - 设置 header 模块的头像
        nav.setAvatar(data.avatar);     // - 设置导航模块的头像
        message.refresh();              // - 刷新消息列表
        cart.refresh();                 // - 刷新购物车列表

        // - 增加下面一行代码
        address.refresh();
    })
  ```
- 我们会越来越疲于应对这些突如其来的业务要求.
- 接下来我们用发布订阅模式重写之后, 对用户信息感兴趣的业务模块将自行订阅登录成功的
  消息事件.当登录成功时, 登录模块只需要发布登陆成功的消息, 而业务放接受到消息之后, 
  就会开始进行各自的业务处理, 登录模块并不关心业务方究竟要做什么, 也不想去了解它们
  的内部细节. 改善后的代码如下:  
  **`8.7-发布订阅模式实现网站登录.html`**
### 8.8 全局的发布-订阅对象
### 8.9 模块间通信
### 8.10 必须先订阅再发布吗
### 8.11 全局事件的命名冲突
### 8.12 JavaScript 实现发布-订阅模式的便利性
### 8.13 小结
