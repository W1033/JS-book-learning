# 第 12 章 -- 享元模式

## 本章目录 (Catalog)
- 12.1 初始享元模式
- 12.2 内部状态与外部状态 
- 12.3 享元模式的通用结构
- 12.4 文件上传的例子
    + 12.4.1 对象爆炸 
    + 12.4.2 享元模式重构文件上传
    + 12.4.3 剥离外部状态
    + 12.4.4 工厂进行对象实例化
    + 12.4.5 管理器封装外部状态
- 12.5 享元模式的适用性
- 12.6 再谈内部状态和外部状态
    + 12.6.1 没有内部状态的享元
    + 12.6.2 没有外部状态的享元
- 12.7 对象池
    + 12.7.1 对象池实现
    + 12.7.2 通用对象池实现
- 12.8 小结

## 生词 (New Words)


## 本章内容 (Content)
- 享元(flyweight) 模式是一种用于性能优化的模式, 'fly' 在这里是苍蝇的意思, 意为蝇量级.
  享元模式的核心是运用共享技术有效支持大量细粒度的对象.

### 12.1 初始享元模式
- 既然只需要区别男女模特, 那我们把 underwear 参数从构造函数中移除, 构造函数
  只接收 sex 参数:
  ```js
    const Model = function(sex) {
        this.sex = sex;
    };
    Model.prototype.takePhoto = function() {
        // - this.underwear 在下面实例上添加.
        console.log(`Sex(性别)=${this.sex} Underwear(试穿)=${this.underwear}`);
    };

    // - 分别创建一个男模特对象和一个女模特对象:
    let maleModel = new Model('男模');
    let femaleModel = new Model('女模');

    // - 给男模特一次穿上所有的男装, 并进行拍照:
    for (let i = 1; i <= 50; i++) {
        maleModel.underwear = `第 ${i} 款样式`;
        maleModel.takePhoto();
    }
    // - 同样, 给女模特依次穿上所有的女装, 并进行拍照:
    for (let j = 1; j <= 50; j++) {
        femaleModel.underwear = `第 ${j} 款样式`;
        femaleModel.takePhoto();
    }
  ```

### 12.2 内部状态与外部状态 
- 12.1 节的这个例子便是享元模式的雏形，享元模式要求将对象的属性划分为内部状态与外部状态
 （状态在这里通常指属性）。享元模式的目标是尽量减少共享对象的数量，关于如何划分内部状态和
  外部状态，下面的几条经验提供了一些指引。
   + 内部状态(属性) 存储于对象内部。
   + 内部状态可以被一些对象共享。
   + 内部状态独立于具体的场景，通常不会改变。
   + 外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。
- 这样一来，我们便可以把所有内部状态相同的对象都指定为同一个共享的对象。而外部状态可以从
  对象身上剥离出来，并储存在外部。
- 剥离了外部状态的对象成为共享对象，外部状态在必要时被传入共享对象来组装成一个完整的对象.
  虽然组装外部状态成为一个完整对象的过程需要花费一定的时间，但却可以大大减少系统中的
  对象数量，相比之下，这点时间或许是微不足道的。因此，享元模式是一种用时间换空间的优化模式.
- 在上面的例子中，性别是内部状态，内衣是外部状态，通过区分这两种状态，大大减少了系统中的
  对象数量。通常来讲，内部状态有多少种组合，系统中便最多存在多少个对象，因为性别通常只有
  男女两种，所以该内衣厂商最多只需要 2 个对象.
- 使用享元模式的关键是如何区别内部状态和外部状态。可以被对象共享的属性通常被划分为
  内部状态，如同不管什么样式的衣服，都可以按照性别不同，穿在同一个男模特或者女模特身上，
  模特的性别就可以作为内部状态储存在共享对象的内部。而外部状态取决于具体的场景，并根据
  场景而变化，就像例子中每件衣服都是不同的，它们不能被一些对象共享，因此只能被划分为外部状态.

### 12.3 享元模式的通用结构
- 12.1 节的示例初步展示了享元模式的威力，但这还不是一个完整的享元模式，在这个例子中
  还存在以下两个问题。
    + 我们通过构造函数显式 new 出了男女两个 model 对象，在其他系统中，也许并不是一开始
      就需要所有的共享对象。
    + 给 model 对象手动设置了 underwear 外部状态，在更复杂的系统中，这不是一个最好的
      方式，因为外部状态可能会相当复杂，它们与共享对象的联系会变得困难。
- 我们通过一个对象工厂来解决第一个问题，只有当某种共享对象被真正需要时，它才从工厂中
  被创建出来。对于第二个问题，可以用一个管理器来记录对象相关的外部状态，使这些外部状态
  通过某个钩子和共享对象联系起来.

### 12.4 文件上传的例子
#### 12.4.1 对象爆炸 
#### 12.4.2 享元模式重构文件上传
#### 12.4.3 剥离外部状态
#### 12.4.4 工厂进行对象实例化
#### 12.4.5 管理器封装外部状态

### 12.5 享元模式的适用性

### 12.6 再谈内部状态和外部状态
#### 12.6.1 没有内部状态的享元
#### 12.6.2 没有外部状态的享元

### 12.7 对象池
#### 12.7.1 对象池实现
#### 12.7.2 通用对象池实现

### 12.8 小结